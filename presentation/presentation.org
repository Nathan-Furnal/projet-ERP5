#+title: Présentation du projet - ERPG5
#+author: Nathan Furnal
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_THEME: white
#+REVEAL_INIT_OPTIONS: slideNumber:true, width:1920, height:1024
#+REVEAL_EXTRA_CSS: ./custom.css
#+language: fr
#+options: date:nil timestamp:nil toc:2

* Présentation
** Présentation du projet
*** Odoo
La partie Odoo est sous =odoo-app=.

- Séparation Modèles et Vues.
- La partie Odoo est dans un /container/ sous Odoo 14 et PostgreSQL 13.
- Données fictives via les fichiers =demo.xml= et =stock_demo.xml=.
- Gestion des permissions par le =security/ir.model.access.csv=.
  
*** Django
- La partie Django est sous =realtorclient=
  + L'application de connexion est sous =odoo_connect=
  + L'application d'achat d'appartement est sous =odoo_realtor=
- La partie Django est locale et nécessite un environnement virtuel en local.
  
* Architecture du projet
** Odoo
*** /Business Object/ Appartement
#+begin_src python
from dateutil.relativedelta import relativedelta

from odoo import api, fields, models
from odoo.exceptions import UserError, ValidationError
from odoo.tools import float_compare, float_is_zero

class RealtorApartment(models.Model):
    _name = 'realtor.apartment'
    _description = 'An apartement unit'

    _sql_constraints = [
        ("check_expected_price", "CHECK(expected_price > 0)", "The expected price must be strictly positive"),
        ("check_best_price", "CHECK(best_price >= 0)", "The best offer price must be positive"),
        ("check_apart_area", "CHECK(apartment_area > 0)", "The apartment area must be strictly positive"),
    ]

    def _default_date_availability(self):
        return fields.Date.context_today(self) + relativedelta(months=3)    

    name = fields.Char("Title", required=True)
    desc = fields.Text("Description")

    img = fields.Image("Apartment's picture")

    availability_date = fields.Date("Available from",
                                    default=lambda self: self._default_date_availability(), copy=False)

    expected_price = fields.Float("Expected Price", required=True)
    best_price = fields.Float("Best Offer", compute="_compute_best_price", help="Best offer received")
    selling_price = fields.Float("Selling Price", copy=False, readonly=True)

    apartment_area = fields.Integer("Apartment area")
    terrace_area = fields.Integer("Terrace Area")

    total_area = fields.Integer("Total area", compute='_compute_total_area')

    # Special   
    state = fields.Selection(
        selection=[
            ("new", "New"),
            ("offer_received", "Offer Received"),
            ("offer_accepted", "Offer Accepted"),
            ("sold", "Sold"),
            ("canceled", "Canceled"),
        ],
        string="Status",
        required=True,
        copy=False,
        default="new",
    )
    active = fields.Boolean("Active", default=True)

    user_id = fields.Many2one("res.users", string="Salesman", default=lambda self: self.env.user)
    buyer_id = fields.Many2one("res.partner", string="Buyer", readonly=True, copy=False)
    offer_ids = fields.One2many("realtor.offer", "property_id", string="Offers")

    @api.depends('apartment_area', 'terrace_area')
    def _compute_total_area(self):
        for prop in self:
            prop.total_area = prop.apartment_area + prop.terrace_area

    @api.depends("offer_ids.price")
    def _compute_best_price(self):
        for prop in self:
            prop.best_price = max(prop.offer_ids.mapped("price")) if prop.offer_ids else 0.0            


    @api.constrains("expected_price", "best_price")
    def _check_price_difference(self):
        for prop in self:
            if (
                not float_is_zero(prop.best_price, precision_rounding=0.01)
                and float_compare(prop.best_price,
                                  prop.expected_price * 90.0 / 100.0, precision_rounding=0.01) < 0
            ):
                raise ValidationError(
                    "The BEST price must be at least 90% of the expected price! "
                    + "You must reduce the expected price if you want to accept this offer."
                )

    @api.constrains("expected_price", "selling_price")
    def _check_price_difference(self):
        for prop in self:
            if (
                not float_is_zero(prop.selling_price, precision_rounding=0.01)
                and float_compare(prop.selling_price,
                                  prop.expected_price * 90.0 / 100.0, precision_rounding=0.01) < 0
            ):
                raise ValidationError(
                    "The SELLING price must be at least 90% of the expected price! "
                    + "You must reduce the expected price if you want to accept this offer."
                )   

    # ------------------------------------------ CRUD Methods -------------------------------------

    def unlink(self):
        if not set(self.mapped("state")) <= {"new", "canceled"}:
            raise UserError("Only new and canceled properties can be deleted.")
        return super().unlink()

    # ---------------------------------------- Action Methods -------------------------------------

    def action_sold(self):
        if "canceled" in self.mapped("state"):
            raise UserError("Canceled properties cannot be sold.")
        return self.write({"state": "sold"})

    def action_cancel(self):
        if "sold" in self.mapped("state"):
            raise UserError("Sold properties cannot be canceled.")
        return self.write({"state": "canceled"})             
#+end_src
*** /Business Object/ Offre
#+begin_src python
from dateutil.relativedelta import relativedelta

from odoo import api, fields, models
from odoo.exceptions import UserError
from odoo.tools import float_compare


class RealtorOffer(models.Model):

    # ---------------------------------------- Private Attributes ---------------------------------

    _name = "realtor.offer"
    _description = "Real Estate Property Offer"
    _order = "price desc"
    _sql_constraints = [
        ("check_price", "CHECK(price > 0)", "The price must be strictly positive"),
    ]

    # --------------------------------------- Fields Declaration ----------------------------------

    # Basic
    price = fields.Float("Price", required=True)

    # Relational
    partner_id = fields.Many2one("res.partner", string="Partner", required=True)
    property_id = fields.Many2one("realtor.apartment", string="Property", required=True)

    # Special
    state = fields.Selection(
        selection=[
            ("accepted", "Accepted"),
            ("refused", "Refused"),
        ],
        string="Status",
        copy=False,
        default=False,
    )    

    # ------------------------------------------ CRUD Methods -------------------------------------

    @api.model
    def create(self, vals):
        if vals.get("property_id") and vals.get("price"):
            prop = self.env["realtor.apartment"].browse(vals["property_id"])
            # We check if the offer is higher than the existing offers
            if prop.offer_ids:
                max_offer = max(prop.mapped("offer_ids.price"))
                if float_compare(vals["price"], max_offer, precision_rounding=0.01) <= 0:
                    raise UserError("The offer must be higher than %.2f" % max_offer)
        return super().create(vals)

 # ---------------------------------------- Action Methods -------------------------------------

    def action_accept(self):
        if "accepted" in self.mapped("property_id.offer_ids.state"):
            raise UserError("An offer as already been accepted.")
        self.write(
            {
                "state": "accepted",
            }
        )
        return self.mapped("property_id").write(
            {
                "state": "offer_accepted",
                "selling_price": self.price,
                "buyer_id": self.partner_id.id,
            }
        )

    def action_refuse(self):
        return self.write(
            {
                "state": "refused",
            }
        )        
#+end_src
*** /Business Object/ Produit

#+begin_src python
from odoo import models, fields, api

class RealtorProduct(models.Model):
    _inherit = 'product.template'

    apart_id = fields.Many2one("realtor.apartment", string="Property", ondelete='cascade')

    list_price = fields.Float(compute='_update_prod_price')

    @api.onchange('apart_id')
    def _update_prod_price(self):
        for el in self:
            el.list_price = el.apart_id.expected_price
#+end_src

** Django
* Le /Business Object/ Appartement
* Vues Odoo
* Chargement des données
* Connexion au service web
* Gestion des stocks
* Interface Django
* Conclusion
* Questions ?
:properties:
:reveal_background: #bde0fe
:end:
